#!/usr/bin/env python
"""
Command-line wrapper for the Fix Archive tool.
Usage: fixarc [args]

This version modifies sys.path and uses runpy to execute the module.
"""

import sys
import os
import runpy

def main():
    """Modify sys.path and use runpy to run the fixarc CLI module."""
    try:
        # Get the directory where this script (fixarc) is located
        script_dir = os.path.dirname(os.path.abspath(__file__))
        # Get the project root directory (one level up)
        project_root = os.path.dirname(script_dir)

        # Check if the project root is already in sys.path
        if project_root not in sys.path:
            # Add the project root to the beginning of sys.path
            sys.path.insert(0, project_root)
            print(f"[Wrapper] Added to sys.path: {project_root}", file=sys.stderr)
        else:
            print(f"[Wrapper] Project root already in sys.path: {project_root}", file=sys.stderr)

        # Modify sys.argv: runpy expects the script name to be the first arg,
        # but when running a module, the module path effectively becomes argv[0].
        # We need to replace our wrapper script name with the target module path
        # or simply remove it, as the module itself will handle sys.argv[1:].
        # Let's keep it simple and let runpy handle argv based on the module.
        # Note: runpy modifies sys.argv internally while running the module.
        # We are passing sys.argv directly, which includes our wrapper path
        # and the user arguments. The module should still parse sys.argv[1:].

        target_module = "fixarc.cli" # Use hyphenated name
        print(f"[Wrapper] Attempting to run module '{target_module}' with sys.path: {sys.path}", file=sys.stderr)

        # Use runpy.run_module to execute the cli module as the main script
        # This is closer to how 'python -m' works internally.
        runpy.run_module(target_module, run_name="__main__")

        # If run_module completes without exception, we assume success (exit code 0)
        # Note: If the module calls sys.exit(), run_module might not return.
        return 0

    except ModuleNotFoundError as mnfe:
        print(f"[Wrapper] Error: runpy could not find module '{target_module}'.", file=sys.stderr)
        print(f"[Wrapper] Details: {mnfe}", file=sys.stderr)
        print(f"[Wrapper] Final sys.path: {sys.path}", file=sys.stderr)
        # Check if the directory exists but is missing __init__.py?
        mod_path_parts = target_module.split('.')
        potential_pkg_dir = os.path.join(project_root, mod_path_parts[0])
        if os.path.isdir(potential_pkg_dir) and not os.path.exists(os.path.join(potential_pkg_dir, "__init__.py")):
             print(f"[Wrapper] Hint: Directory '{potential_pkg_dir}' exists but is missing an '__init__.py' file.", file=sys.stderr)
        return 1
    except Exception as e:
        # Catch errors during runpy execution or other wrapper errors
        # The executed module might raise exceptions or call sys.exit
        if isinstance(e, SystemExit):
            # If the module called sys.exit(), propagate the exit code
            return e.code
        else:
            print(f"Error running fixarc wrapper or executing module: {e}", file=sys.stderr)
            return 1

if __name__ == "__main__":
    # runpy handles execution, main() returns the effective exit code
    exit_code = main()
    sys.exit(exit_code) 