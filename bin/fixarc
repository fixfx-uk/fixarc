#!/usr/bin/env python
"""
Command-line wrapper for the Fix Archive tool.
Usage: fixarc [args]

This version modifies sys.path and uses runpy to execute the module.
"""

import sys
import os
import runpy
import platform

def main():
    """Modify sys.path and use runpy to run the fixarc CLI module."""
    try:
        # Get the directory where this script (fixarc) is located
        script_dir = os.path.dirname(os.path.abspath(__file__))
        # Get the project root directory (one level up)
        project_root = os.path.dirname(script_dir)

        # Check if the project root is already in sys.path
        if project_root not in sys.path:
            # Add the project root to the beginning of sys.path
            sys.path.insert(0, project_root)
            print(f"[Wrapper] Added to sys.path: {project_root}", file=sys.stderr)
        else:
            print(f"[Wrapper] Project root already in sys.path: {project_root}", file=sys.stderr)

        # --- Set up NUKE_PATH environment variable before running the CLI ---
        print(f"[Wrapper] Original NUKE_PATH: {os.environ.get('NUKE_PATH', 'Not Set')}", file=sys.stderr)
        
        # Helper function to normalize paths
        def normalize_path(path):
            return str(path).replace("\\", "/")
        
        # Try to find additional plugin paths that might be needed
        plugin_paths = []
        
        # Check if DasGrain path exists and add it
        dasgrain_paths = [
            "Z:/pipe/plugins/nuke/DasGrain",
            "//192.168.14.252/FixStore/pipe/plugins/nuke/DasGrain"
        ]
        for path in dasgrain_paths:
            if os.path.exists(path):
                plugin_paths.append(normalize_path(path))
                print(f"[Wrapper] Added DasGrain plugin path: {path}", file=sys.stderr)
        
        # Try importing fixenv for more paths
        try:
            # First add fixenv to path if needed
            if os.path.exists(os.path.join(project_root, '..', 'fixenv')):
                fixenv_path = os.path.abspath(os.path.join(project_root, '..', 'fixenv'))
                if fixenv_path not in sys.path:
                    sys.path.insert(0, fixenv_path)
                    print(f"[Wrapper] Added fixenv to sys.path: {fixenv_path}", file=sys.stderr)
            
            # Now try to import
            from fixenv import NUKE_MAIN_PATH
            nuke_main_path = str(NUKE_MAIN_PATH)
            print(f"[Wrapper] Found fixenv.NUKE_MAIN_PATH: {nuke_main_path}", file=sys.stderr)
            plugin_paths.append(nuke_main_path)
            
            # Also try to get other plugin paths from fixenv
            try:
                from fixenv import NUKE_PLUGIN_PATH
                if NUKE_PLUGIN_PATH:
                    plugin_paths.append(str(NUKE_PLUGIN_PATH))
                    print(f"[Wrapper] Found fixenv.NUKE_PLUGIN_PATH: {NUKE_PLUGIN_PATH}", file=sys.stderr)
            except ImportError:
                print("[Wrapper] NUKE_PLUGIN_PATH not available in fixenv", file=sys.stderr)
        except ImportError:
            print("[Wrapper] Could not import NUKE_MAIN_PATH from fixenv", file=sys.stderr)
        
        # Get existing NUKE_PATH or initialize empty
        nuke_path = os.environ.get('NUKE_PATH', '')
        
        # Determine path separator based on OS
        path_sep = ';' if platform.system() == 'Windows' else ':'
        
        # Combine all paths
        if plugin_paths:
            joined_plugin_paths = path_sep.join(plugin_paths)
            if nuke_path:
                nuke_path = f"{joined_plugin_paths}{path_sep}{nuke_path}"
            else:
                nuke_path = joined_plugin_paths
                
        os.environ['NUKE_PATH'] = nuke_path
        print(f"[Wrapper] Set NUKE_PATH: {nuke_path}", file=sys.stderr)
        
        # --- End of NUKE_PATH setup ---

        target_module = "fixarc.cli" # Use fully qualified module name with package prefix
        print(f"[Wrapper] Attempting to run module '{target_module}' with sys.path: {sys.path}", file=sys.stderr)

        # Use runpy.run_module to execute the cli module as the main script
        # This is closer to how 'python -m' works internally.
        runpy.run_module(target_module, run_name="__main__")

        # If run_module completes without exception, we assume success (exit code 0)
        # Note: If the module calls sys.exit(), run_module might not return.
        return 0

    except ModuleNotFoundError as mnfe:
        print(f"[Wrapper] Error: runpy could not find module '{target_module}'.", file=sys.stderr)
        print(f"[Wrapper] Details: {mnfe}", file=sys.stderr)
        print(f"[Wrapper] Final sys.path: {sys.path}", file=sys.stderr)
        # Check if the directory exists but is missing __init__.py?
        mod_path_parts = target_module.split('.')
        potential_pkg_dir = os.path.join(project_root, mod_path_parts[0])
        if os.path.isdir(potential_pkg_dir) and not os.path.exists(os.path.join(potential_pkg_dir, "__init__.py")):
             print(f"[Wrapper] Hint: Directory '{potential_pkg_dir}' exists but is missing an '__init__.py' file.", file=sys.stderr)
        return 1
    except Exception as e:
        # Catch errors during runpy execution or other wrapper errors
        # The executed module might raise exceptions or call sys.exit
        if isinstance(e, SystemExit):
            # If the module called sys.exit(), propagate the exit code
            return e.code
        else:
            print(f"Error running fixarc wrapper or executing module: {e}", file=sys.stderr)
            return 1

if __name__ == "__main__":
    # runpy handles execution, main() returns the effective exit code
    exit_code = main()
    sys.exit(exit_code) 